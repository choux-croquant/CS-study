# Architecture

**아키텍처**는 컴퓨터 시스템의 기능, 조직, 구현에 대한 법칙과 방법을 정의하는 개념이다. 추가적으로 명령어 집합 구조(ISA), 마이크로 아키텍쳐의 설계와 논리 설계 및 구현을 의미한다.

구체적으로는 다음의 내용들이 아키텍처로 정의될 수 있다.

+ 메모리 구조 (register, cache, memory, disk)
+ 연산이 동작하는 방식의 정의
+ 명령어에 대한 정의
+ Input / Output
+ 데이터의 타입과 크기에 대한 정의
+ 가상화, 다중처리 등



### Microarchitecture

**마이크로아키텍처**는 컴퓨터의 CPU또는 이와 관련된 전자 회로에 대한 설명으로, 하드웨어의 운영에 대해 기술하는 내용이다. 마이크로아키텍처에서 고려하는 요소는 구체적으로 다음과 같은 것들이 있다.

+ ISA를 실행할 때의 속도, 에너지, 비용등의 요소를 분배하는 것
+ 파이프라이닝 시 파이프의라인의 수와 깊이를 정의하는 것
+ 캐시 사이즈, 반도체 칩의 크기와 비용 제조가능 여부를 고려하는 것
+ 버스, ALU의 구조 등을 결정하는 것



아키텍처의 세부 사항을 정의하는 것을 마이크로 아키텍처라고 이해할 수 있다. 따라서 같은 아키텍처로 제작된 CPU에서 마이크로아키텍처가 다른 제품들이 다수 존재할 수 있다. 

예를 들어 AMD Phenom X4 와 Intel Atom의 경우 동일한 x86 instruction set의 아키텍처를 가지지만 CPU 코어의 개수나 전력 소모등의 요소가 다르다.



### ISA(Instruction Set Architecture)

ISA는 명령어 집합 구조로, 마이크로프로세서가 인식해서 기능을 이해하고 실행할 수 있는 기계어 명령어를 의미한다. **최하위 레벨의 프로그래밍 인터페이스**로, 프로세서가 실행할 수 있는 모든 명령어들을 포함한다.

명령어의 종류에는 다음과 같은 분류들이 존재한다.

+ Data Transfer : LD, ST, ...
+ ALU(Arithmetic Logic Unit) : ADD, SUB, AND, ...
+ 제어 흐름(상위 개념에서 for 등) : BEZQ, JAL, TRAP, ...
+ 부동소수점 관련 : ADD.D, SUB.S, ...
+ 게임 콘솔, 그래픽 카드 등 멀티미디어(SIMD) : ADD.PS, SUB.PS, ...
+ 문자열 : REP MOVSB(x86)



**Addressing Mode**

명령어 주소 지정방식이라는 의미이며, 피연산자를 지정하기 위해 명령어 속에 있는 주소 필드의 값을 수정하거나 다른 것으로 대체하는 것들을 규정한다.

1. Immediate addressing : 피연산자가 바로 instruction에 포함되는 방식으로 수 크기에 제한이 있지만 매우 빠르다. ex) ADD 5
2. Direct Addressing: instruction에 피연산자 값의 주소가 들어간다. ex) ADD A
3. Indirect Addressing: instruction에 피연산자 값의 주소를 가리키는 포인터가 들어간다. 실행에 2번의 메모리 접근을 필요로 하므로 비교적 느리지만 주소 공간이 크다. ex) ADD (A)

4. Register Addressing: direct 방식과 유사하게 직접 주소를 가리키지만 메모리 주소가 아니라 레지스터 주소를 가리킨다.
5. Register Indirect Addressing: instruction의 주소 필드는 레지스터를 가리키고, 레지스터는 메모리에 존재하는 피연산자의 주소값을 가리킨다. 주소 공간이 비교적 넓고 한 번의 메모리 접근을 요구한다.
6. Displacement Addressing: instruction이 주소 필드가 주소와 함께 변위값을 가진다. 변위 값을 기준으로 주소를 더하는 등의 방식으로 접근하는 방식이다. 세부적으로 여러 방식이 존재한다.
7. Stack Addressing: 메모리 주소를 포함하지 않은 형태로 이루어진 구조이다. ex) ADD -> 2개를 pop 하여 더하기
8. 그 외에도 Absolute, Scaled 등의 방식이 존재한다.



**ISA Encoding**

instruction를 나타내는 방식에는 현재 고정 길이 방식과 가변 길이 방식이 존재한다.

 고정 길이 방식

+ 바이트 수가 고정되어 Decoding이 간편하다.
+ 파이프라이닝 구현이 쉽다.
+ 컴파일러의 최적화 과정이 복잡해진다.
+ 명령 길이가 고정되어 코드 효율이 낮다.
+ ex) MIPS(4-bytes), PowerPC, ARM ... 

가변 길이 방식

+ 컴파일러 작성이 쉽고, 코드 효율이 좋다.
+ 명령어의 길이를 줄여 메모리와 캐시 용량을 최소화 할 수 있다.
+ 하나의 명령어가 복잡하여 Decoding에 시간이 오래 걸릴 수 있으며 해석 회로가 복잡하다.
+ 명령어의 길이가 달라 동시의 여러 명령을 처리하기 어렵다.
+ ex) x86(1-byte ~ 17-bytes)