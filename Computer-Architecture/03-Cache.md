# Cache 

일반적으로 컴퓨터의 성능은 메모리의 bandwidth 와 latency 에 의해 제한되는 경우가 많다. Latency 는 한번 접근하는 데 걸리는 시간을 의미하며 보통 메모리에 접근하는 시간이 프로세서의 사이클 시간보다 훨씬 길기 때문에 제한이 걸린다. (Latency = Register << SRAM << DRAM)

Bandwidth 는 단위 시간당 접근하는 횟수를 의미한다. 실제로 만들어지는 메모리의 경우 메모리 클럭(RAM을 동작시키기 위해 메인보드에서 발생하는 주기 신호 MHz 단위) x 메모리 버스 폭(메모리 입출력 라인의 개수를 의미, bit 단위) 의 값으로 계산되어 표기된다.

Locality

지역성의 개념은 캐시를 효율적으로 동작하기 위해, 자주 사용하는 데이터에 대한 원리를 정의한 것이다. 지역성에는 시간 지역성(Temporal locality) 와 공간 지역성(Spatial locality) 두 가지가 존재한다. 

시간 지역성은 최근 접근한 데이터에 다시 접근하는 경향을 말한다. 예를 들어 for문을 통해 i 값을 1씩 늘려갈 때 짧은 시간안에 변수 i에 여러 번 접근하게 되는 경우 시간 지역성이 있는 것이다.

 공간 지역성은 최근 접근한 데이터의 주변 공간에 다시 접근하는 경향을 말한다. 배열을 순회하는 경우 주변 인덱스 값에 자주 접근하게 되므로 공간 지역성이 존재하는 것이다. 메모리 주소에 접근할 때 근처의 블록 전체를 캐시에 가져온다면, 캐시의 효율성를 향상시킬 수 있다.



Cache의 종류

+ L1 Cache : 프로세서와 가장 가까운 캐시로, instruction 캐시 (메모리의 text 영역 데이터를 담당) 와 Data Cache (text를 제외한 영역을 담당) 으로 나뉜다.
+ L2 Cache : 용량이 큰 캐시로 L1 캐시처럼 나뉘어 있지 않다.
+ L3 Cache : 멀티 코어 시스템에서 여러 코어가 공유하는 캐시



Cache Metrics

+ Hit latency : Hit 이란 프로세서에서 요청한 데이터가 캐시에 존재하는 경우를 의미하며, 히트 레이턴시는 히트가 발생하여 캐싱된 데이터를 가져올 때 걸리는 시간을 의미한다. 

+ Miss latency : Miss 는 반대로 요청한 데이터가 캐시에 존재하지 않는 경우를 의미하며 미스 레이턴시는 미스가 밸생하여 상위 캐시에서 데이터를 가져오거나 메모리에서 데이터를 가져올 떄 소모되는 시간을 의미한다.

+ Average access time(평균 접근 시간) : 캐시 성능을 수치로 보여줄 수 있는 지표로 히트 레이턴시와 미스 레이턴시를 통해 정의된다.
  $$
  AAT = {HIT latency} + {Cache\space misses \over Cache\space accesses} *{Miss\space latency}
  $$
  따라서 캐시의 성능을 높이기 위해서는 AAT를 줄여야 하므로 다음의 방법들을 사용할 수 있다.

  1. 캐시 크기를 줄여 히트 레이턴시를 줄이는 방법(응답이 빨라짐)
  2. 캐시 크기를 늘려 미스의 비율을 줄이는 방법
  3. 캐시 자체의 성능 향상을 통해 레이턴시 감소



Cache Mapping

+ 블록 사상 방식 : 블록을 메모리에서 가져와 캐시에 어떤 방식으로 mapping 할 지 정의하는 것

  + 직접 사상 : 메모리 블록을 정해진 하나의 캐시 블록에만 매핑

    + 태그의 길이가 짧고 CPU태그를 하나의 캐시 태그와 비교하기 때문에 하나의 비교기만 있으면 되기 때문에 하드웨어 구현이 단순하고 접근 속도가 빠르다.
    + 동일한 캐시 블록에 매핑되는 다른 메모리 블록을 번갈아 참조할 때 캐시 블록에 충돌이 계속하여 발생하므로 적중률이 떨어진다. 이러한 단점으로 인해 대용량 캐시 메모리일 경우에만 주로 이용한다.

  + 완전 연관 사상 : 메모리 블록을 어떠한 캐시 블록에도 매핑할 수 있다.

    + 직접 사상에 비해 적중률이 높지만, CPU태그를 모든 캐시 태그와 병렬로 비교해야 하므로 여러개의 비교기가 필요하며 태그의 길이도 길다.

  + 집합 연관 사상 : 메모리 블록을 정해진 블록 집합 내에 사상

    + 전체가 아닌 일부 캐시 태그에 대해 연관 탐색을 수행하므로 비교적 적은 개수의 비교기가 필요하다. 따라서 완전 연관 사상에 비해 비용이 저렴하다. 직접 사상과 완전 연관 사상의 절충안.

    

Indexing

32비트 주소를 예시로 들면, 블록 개수가 1024개이고 블록 크기가 32바이트일 때 다음과 같이 나타낸다.

Offset bit : log(Block size) 의 값으로 예시에서는 5bit, 오프셋 비트를 통해 블록 내에서 1바이트를 선택한다.

Index bit : 메모리, 캐시의 주소를 나타내기 위한 비트로 log(memory size / block size)의 값을 가진다. 위에서는 블록 개수가 주어져 있으므로 log(block number) 인 10bit 가 index bit으로 할당된다.

tag bit : address bits - (index bits + log(block size)) 로 나타낼 수 있으며 여기서는 32 - (10 + 5) = 17bit이다. 태그 비트는 인덱스의 충돌을 줄이기 위한 역할을 한다.

valid bit : 해당 블록에 올바른 인덱스 값이 존재하는 지를 boolean(0, 1) 으로 나타내는 역할을 하는 1bit이다. 



Block replacement

캐시 공간이 부족하여 캐시 블록을 비워야 할 경우 어떤 캐시 블록을 비울 것인지를 결정하는 개념

+ Belady`s MIN 알고리즘 : 가장 오랫동안 참조되지 않을 블록을 교체한다.(미래 예측 필요)
+ LRU(Least Recently Used) : 최근에 가장 참조되지 않은 것 부터 교체하는 방식으로, 높은 적중률을 보인다. 하지만 캐시의 상태를 접근할 때마다 업데이트하므로 추가적인 정보가 포함되어 구현 비용이 높다. 따라서 작은 스케일에서 사용하는 것이 좋다.
+ Random : 임의의 캐시 블록을 선택하여 교체하는 방식으로, 효율성을 보장하지 못하지만 구현이 쉽고 저렴하다.
+ FIFO : 캐시 메모리에 먼저 적재된 블록부터 교체하는 방식으로, 역시 효율성을 보장할 수 없지만 time locality를 기반으로 하며 구현 비용이 저렴하다.
+ NMRU(Not Most Recently Used) : FIFO 방식을 기반으로 하되, 최근에 많이 참조된 블록에 대해서 예외를 두는 방식이다.



Write Strategy

데이터는 메모리와 캐시 두 곳에 동시에 존재할 수 있으며 같은 데이터라면 같은 정보를 가지고 있어야 한다. 하지만 캐시를 사용할 경우 동일한 블록에 다른 값을 가지는 현상이 발생하게 된다.

블록을 갱신하는 방식은 캐시와 메모리의 내용을 일치시키는 시점에 따라 크게 두 가지 전략으로 나뉜다.

+ Write Through(즉시 쓰기) : write연산 시 항상 메모리와 캐시에 둘 다 write 하는 방법. 구현이 간단하지만 트래픽이 높아 성능 저하가 크게 일어날 수 있다. Write buffer를 활용하여 완화시킬 수 있다.
+ Write back(나중 쓰기) : write연산 시 새로운 값은 캐시에만 쓰고, 나중에 캐시에서 나가는 블록이 write연산에 의해 수정되었을 경우에만 메모리에 write하는 방식. 이 방식의 경우 데이터가 변경되었는지 여부를 확인하기 위해 캐시 블록마다 dirty bit을 추가하여야 한다. 속도가 빠르고 메모리 트래픽이 적지만 구현이 즉시 쓰기보다 어렵다.

+ Write-allocate : 데이터를 변경할 주소가 캐싱된 상태가 아니면(Cache miss) 사용하는 방식으로, 해당 데이터를 캐싱한다.
+ No Write-allocate : 역시 Cache miss의 경우 사용하는 방식으로, 메모리에만 write한다.



Cache Miss - 3C

Cache miss 의 유형은 다음의 3가지로 이것을 개선하는 것을 통해 캐시 메모리의 성능을 높일 수 있다.

+ Compulsory Miss(강제 실패) : 메모리 블록의 최초 접근에 의한 캐시 미스, 블록 크기를 크게 하거나 접근 가능성이 큰 블록의 prefetch를 통해 줄여볼 수 있다.
+ Capacity Miss(용량 실패) : 캐시 메모리의 유한한 용량으로 인해 발생하는 미스, 블록 교체 후 다시 그 블록을 가져올 때 발생한다. 캐시 메모리가 프로그램에 사용되는 데이터를 담기에 부족한 경우이다. 캐시 용량을 크게 하는 것을 통해 해결할 수 있다.
+ Collision Miss(충돌 실패) : 다수의 블록이 동일한 집합/블록에 매핑될 때 발생하는 미스, 완전 연관 사상에서는 발생하지 않는 미스이다. 연관도를 높이는 것을 통해 줄일 수 있다.
