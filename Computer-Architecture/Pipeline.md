# Pipeline

데이터 처리 단계의 출력이 다음 단계의 입력으로 이어지는 연결된 구조를 의미한다. 데이터 처리 단계를 동시에, 또는 병렬적으로 수행하는 것을 통해 효율성을 높일 수 있다. 



### 명령어 파이프라인

CPU 회로 안에서 여러 명령어(instruction) 들이 단계적으로 수행될 수 있도록 하는 개념. 파이프라이닝을 통해 병렬적으로 작업을 수행함으로써 클럭의 효율을 높일 수 있다. 예시로 MIPS 의 파이프라인을 보면 5단계로 이루어진 것을 볼 수 있다.

*클럭 : 디지털 회로의 전기 진동수를 의미, Hz단위로 표기하며 전기 신호를 통해 0과 1의 값을 변경하는 것으로 컴퓨터를 동작시킨다. 즉 클럭의 속도는 컴퓨터 프로세스의 동작 속도라고 할 수 있다

1. Instruction Fetch : 메모리에서 명령어를 가져오는 단계
2. Instruction Decode : 명령어를 decoding하여 레지스터를 읽는 단계
3. Execute : 연산을 수행하고 주소를 계산하는 단계
4. Memory Access : 메모리에 있는 피연산자에 접근하는 단계
5. Writeback : 연산의 결과값을 레지스터에 기록하는 단계



**마이크로프로세서의 성능을 정의하는 공식**
$$
{Time \over program} = {Instruction \over Program} * {Cycles \over Instruction} * {Time \over Cycle}
$$

+ 프로그램 당 명령어의 수는 소스코드, 컴파일러 기술, ISA에 영향을 받는 요소
+ 명령어 당 사이클(클럭)의 수는 CPI로, ISA와 마이크로아키텍처에 따라 변화하는 요소
+ 클럭당 시간소모는 마이크로아키텍처와 전반적인 기술 수준에 영향을 받는 요소이다.



**CPI**

프로그램에서 각 명령어의 사이클 수와 명령어가 프로그램에서 차지하는 비율을 통해 CPI를 계산할 수 있다.
$$
CPI = \sum cycle*{frequency}
$$
 CPI 와 Clock rate(Hz 단위) 를 통해 CPU time을 구할 수 있다. CPU time 은 명령어의 수 * CPI / Clock rate로 나타낼 수 있다. 즉 Clock rate가 높거나 CPI 또는 명령어의 개수가 적을 때 실행시간이 짧아진다.

 

**해저드**

명령어들이 다른 파이프라인과의 상호작용에서 여러 문제가 발생할 수 있는데 이를 해저드라고 한다. 해저드에서는 크게 3가지 종류가 존재한다.

+ 구조적 해저드 : 프로세서의 자원 부족으로 인해 발생하는 해저드, 파이프라인의 다른 명령어가 이미 자원을 사용하고 있는 경우에 발생한다. 자원이 사용 가능할 때까지 파이프라인을 멈추거나(Stall), 추가적인 하드웨어를 도입하여 자원 자체를 늘리거나(Duplicate), 미리 적절하게 구조적 해저드를 피하도록 프로그래머가 직접 스케줄링을 하는 방식(Schedule) 을 통해 해결할 수 있다.

  

+ 데이터 해저드 : 이전에 수행된 명령어의 결과로 인해 발생하는 해저드, 현재 수행하는 명령어가 이전에 수행된 결과에 종속된 경우 등이 해당한다. 데이터 해저드는 다시 3가지로 나뉘어 진다.

  + RAW(Read After Write) : 먼저 실행되고 있는 파이프라인에서 아직 Write Back 단계를 지나지 않았을 때 다음 파이프 라인에서 결과값을 요구하는 경우에 아직 결과값이 없으므로 쓰레기 값이 들어가게 된다. (종속성 문제). 이 경우 Execute 단계에서 결과값을 즉시 다음 파이프라인에 전달하거나(Data forwarding), WB 단계가 지날 때까지 다음 파이프라인을 멈추거나(Stall), 레지스터에 값을 기록하는 방식(Register scoreboarding) 등으로 문제를 해결할 수 있다.

  + WAR(Write After Read) : 병렬연산에서 발생하는 문제로, 한 연산의 피연산자로 존재하는 값이 다른 연산의 결과값으로 저장되는 경우 발생한다. 이러한 경우 어느 스레드가 먼저 연산을 끝내는지에 따라 결과값이 바뀌게 된다. 이 역시 스코어보딩 등의 방법으로 해결할 수 있다.

  + WAW(Write After Write) : 병렬연산에서 발생하는 문제로, 두 개 이상의 연산에서 결과값에 해당하는 변수가 같을 경우에 발생한다. 이 역시 WAR과 같이 어느 스레드가 먼저 완료되는지에 따라 최종적으로 결과값으로 저장되는 값이 변하므로 문제가 된다. WAW 해저드 역시 스코어 보딩으로 해결할 수 있다.

    

+ 제어 해저드 : 명령어의 실행 순서를 변경하는 Branch, Jump 등의 분기 명령어를 사용할 경우 분기 명령어의 결과값을 필요로 하는 다른 연산들이 stall 되는 것을 제어 해저드라고 한다. if~else 문과 같은 경우 만약 조건이 false로 평가되면 true일 때 실행되는 연산들이 바로 실행되면 안될 것이다. 이 때 조건을 분기하여 판정하는 명령이 실행되는 동안 조건 판정 이후에 진행되는 파이프라인이 stall 되고 이러한 것을 decoding bubble이라고 한다.

  + 제어 해저드를 신경써서 프로그램을 작성하면 성능이 개선되는 경우도 존재한다. 프로그램의 행 수를 늘려서 루프를 줄이는 경우나 루프의 내부를 나열하여 루프를 줄이는 방법(Loop unrolling) 을 사용하는 경우 루프가 굉장히 많을 때 조건분기에 의해 stall되는 사이클을 줄여 성능이 올라갈 수 있다.

  + ```python
    # loop unrolling
    # 아래의 반복문의 경우 조건분기가 1/4로 줄어들어 N이 클 경우 성능이 향상될 수 있다.
    
    for i in range(1, N):
    	a[i] += 1
    
    for i in range(1, N, 4):
    	a[i] += 1
    	a[i+1] += 2
    	a[i+2] += 3
    	a[i+3] += 4
    ```





