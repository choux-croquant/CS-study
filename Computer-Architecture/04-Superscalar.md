# Superscalar

CPU 내에 파이프라인을 여러 개 두어 instruction 을 동시에 실행하는 기술을 의미한다. IPC(Instructions Per Cycle) 을 1 이상으로 만들어 CPI 을 1 이하로 줄일 수 있다. 동시에 처리 가능한 명령어 개수에 ㄸ라 N-wide, N-way superscalar 등으로 표현한다. 이 때 이상적으로는 N 개의 명령어를 동시에 fetch할 수 있지만 실제로는 명령어 사이의 의존성 등으로 인해 N개 보다 작은 수를 fetch 한다.

파이프라이닝의 해저드와 같은 개념으로 의존성 문제가 발생할 경우 superscalar의 효과가 좋지 않을 수 있다.

1. 데이터 의존성
   + 실행 순서를 보장해야 하는 경우 - 데이터 해저드와 같다.

2. 자원 의존성
   + 같은 자원(연산 장치)을 요구하는 경우 - 구조적 해저드
3. 프로시저 의존성
   + 분기 명령어에 의해 생기는 의존성, 분기가 종료될 때까지 stall 되는 경우 등. (제어 해저드)



**OOO(Out-of-Order) Processors**

비순차적 명령어 처리를 의미하는 단어, superscalar 기술을 사용할 경우 위의 의존성 문제에 의해 발생하는 효율의 감소를 줄이기 위해서 명령어를 주어지는 순서대로 처리하는 것이 아니라 종속성이 낮은 순서대로 처리하는 방식이다. OOO processor 는 다음의 방식으로 동작한다.

1. 명령어를 읽어들인다.
2. 명령어 대기열(Reservation Station)에 명령어를 배치한다. 리오더 버퍼(Reorder buffer)에도 할당한다.
3. 대기열에 있는 명령어들은 자신의 피연산자(operand)가 완료가 되는지 계속 명령어 완료 결과를 엿듣는다.
4. 피연산자가 모두 완료되면 이 명령어는 비로소 실행이 될 수 있고, 연산 장치(execution unit)에 필요한 장치를 요구한다.
5. 필요한 장치를 받으면 대기열에서 빠지고 실행이 된다(리오더 버퍼에는 계속 남아있어야 한다).
6. 실행을 마치면 이 결과를 대기열에서 기다리는 명령에들에게 뿌린다(broadcasting).
7. 리오더 버퍼에 자신이 완료되었다고 표시한다. 만약 리오더 버퍼에서 자신이 가장 오래된 명령어라면 비로소 자신의 연산 결과(레지스터 혹은 메모리 결과)를 반영(commit)한다.



**Reorder buffer**

버퍼의 한 종류로, 비순차적 명령어 처리 방식에서 명령어의 완료 순서를 보장하기 위한 장치이다. 비순차적으로 실행이 완료된 명령어들을 바로 commit 해버린다면 프로그램 오류가 발생할 것이다. 따라서 실행이 끝난 명령어는 reorder buffer 에 저장되며, 이 때 완료된 순서가 아닌 원래의 순서로 저장된다. 

원래의 순서대로 저장하기 위해서 위의 OOO processor 동작의 1번 과정이 필요하다(Reservation station 에 명령어를 넣을 때 버퍼에 같이 넣는 과정). 원래의 순서를 보장해 놓은 상태에서 완료된 명령어는 체크하는 방식으로 동작된다. 