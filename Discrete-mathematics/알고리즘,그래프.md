영상: https://www.youtube.com/playlist?list=PLD8rdlfZeJk6evHY9NsnBqXKrreNbTqFv

### 알고리즘
문제를 해결하기 위한 절차를 기술한 것으로 **누구나 정해진 절차대로 실행**할 수 있어야 한다. 또한 이 절차를 수행할 경우 **동일한 입력값**에 대해 **동일한 출력값**을 구할 수 있어야 한다. 출력값은 **일정한 시간**안에 구할 수 있어야 한다. 즉 무한한 시간이 걸리는 절차는 알고리즘이라고 하기 어렵다.

+ Formal definotion fo algorithm
  + 순서대로 정의된 절차 : 분명한 순서가 존재하며, 실행한 동작 이후 다음 동작이 분명해야 한다.
  + 명확성 : 모든 동작은 명확하게 정의되어야 하며, 실행 가능해야 한다.
  + 반드시 원하는 결과가 나와야 한다.
  + 일정한 시간 안에 실행되어야 한다.

#### a. 알고리즘의 구조

알고리즘에는 보편적으로 정해진 구조들이 존재한다. 아래의 구조들은 모든 프로그래밍 언어에서 기본적으로 제공하는 구조로 기본 구조라고 할 수 있다.

+ 순차적 구조 : 동작이 순서대로 정해지는 구조
+ 분기 구조 : 조건에 따라 수행할 동작이 분기되는 구조, 분기는 2개 (true or false) 또는 여러 개로 나뉠 수 있다(switch)
+ 반복 구조 : 조건을 만족하는가 여부에 따라 일정한 구간을 반복하게 되는 구조.
+ 점프 구조 : 순차적으로 수행하는 중에 다른 동작으로 이동하게 되는 구조



#### b. 알고리즘의 기술 방법

알고리즘의 구조를 반영하여 절차를 기술하는 방식에는 여러 가지가 존재한다.

+ 플로우차트 : 알고리즘 구조를 의미하는 정해식 도식으로 알고리즘을 표현하는 차트
+ 프로그래밍 언어의 코드 : 특정 프로그램 언어의 문법을 알아야 한다는 단점.
+ 의사코드(Psedocode) : 프로그래밍 언어 코드의 전 단계에 해당하는 개념, 프로그램 언어들이 사용하는 구조를 그대로 이용한다. 보다 보편적으로 기술할 수 있는 방법이다.



### 오일러 순환과 해밀턴 순환
#### 그래프?

정점과 정점들을 연결하는 선들로 이루어진 집합. G = {V, E} 로 집합 형태로 표현한다. 현실 세계의 많은 문제들을 모델링할 때 그래프의 형태로 정리되는 경우가 많기 때문에 그래프를 잘 이해하는 것이 문해를 해결함에 있어 중요하다.



#### 오일러 경로, 순환, 그래프

+ 오일러 경로 : 그래프의 모든 연결선을 한 번만 방문하는 경로
+ 오일러 순환 : 시작점과 끝점이 동일한 오일러 경로를 의미한다.
+ 오일러 그래프 : 오일러 순환이 존재하는 그래프
+ 오일러 경로를 갖기 위한 필요충분 조건
  + 2개 이상의 정점을 갖는 루프가 없는 연결 그래프에서 홀수 차수를 갖는 정점이 하나도 없거나, 오직 두 개만 존재해야한다.
  + 모든 정점의 차수가 짝수이면 오일러 순환이 존재한다.
  + Why? - 정점의 차수가 홀수라는 것은 그 정점에 머무르게 된다는 의미를 가진다. 정점을 중간 정점과 끝 or 시작 정점으로 나누어 생각하면 중간 정점의 경우 중간 정점에 머무르면 그래프가 정립하지 않으므로 중간 정점은 항상 짝수개의 차수를 가진다. 반면 끝점과 시작점은 홀수 차수를 가지게 된다. 즉 시작점과 끝점이 다른 오일러 경로를 가지는 경우 단 2개의 홀수 차수 정점이 존재하고, 시작점과 끝점이 같다면 홀수 차수 정점이 존재하지 않는다는 의미가 된다.
  + 오일러 경로, 순환을 가지는지 확인하는 알고리즘을 작성한다면 복잡도는 n개의 정점에 대해 최대 n-1개의 연결선이 존재하는지 확인하므로 O(n^2) 이다.



#### 해밀턴 경로, 순환

+ 해밀턴 경로 : 그래프의 모든 정점을 정확히 한 번만 지나는 경로

+ 해밀턴 순환 : 시작점과 끝점이 같은 해밀턴 경로

+ 해밀턴 순환을 확인하는 알고리즘

  + 그래프에서 존재할 수 있는 모든 경로에 대해 확인하는 방법. (완전탐색법)
  + 탐색해야 하는 경로의 수는 경로를 나타내는 트리의 리프 수로 n개의 정점에 대해 2^n개라고 할 수 있다.
  + 즉 복잡도는 O(x^n) 으로 지수식으로 나타나는 어려운 문제(시간이 매우 오래걸림)이다.
  + 유사한 복잡도를 가지는 문제로는 암호 해독, 바둑, Bin packing 문제 등이 있다.
  + 해밀턴 순환을 확인하는 대표적인 문제 > TSP(Traveling Salesman Problem)

  

### 기본 용어
그래프의 기본 용어

+ 인접(adjacent) / 접합(incident) : 연결선 e = (u, v) 가 존재할 때 정점 u와 정점 v를 인접했다고 하며, 간선 e는 정점 u, v에 접합한다고 표현한다. 
+ 루프(loop) : 연결선의 두 끝점이 같은 정점인 경우 이 연결선을 루프라고 한다.
+ 다중 연결선 : 두 정점의 연결선이 두 개 이상인 경우를 말한다.
+ 단순 그래프(simple graph) : 루프나 다중 연결선이 없는 그래프를 의미한다.

+ 차수(degree) : 정점에 연결된 연결선의 수, 정점을 u라고 하면 deg(u) 와 같이 표현할 수 있다. 
  + 그래프의 모든 정점의 차수의 합은 모든 연결선의 두 배이다.
+ 연결(connected) : 두 정점 u, v 사이에 연결선이 존재하면 두 정점은 연결되었다고 표현한다.
  + 연결 그래프 : 그래프 내의 모든 정점에 대해 어느 두 정점을 잡아도 경로가 존재하는 그래프
  + 비연결 그래프 : 그래프 내의 하나 이상의 정점 쌍에 대해 경로가 존재하지 않는 그래프 
+ 길이(length) : 두 정점의 경로를 구성하는 연결선의 개수
+ 거리(distance) : 두 정점간의 최단 경로의 길이
+ 닫힌 경로(closed path) : 여러 정점으로 구성된 경로가 존재할 때, 경로의 시작 정점과 끝 정점이 같은 경우를 의미한다.
+ 순환(cycle / circuit) : 3개 이상의 연결선을 갖는 경로에서, 어떤 연결선도 중복되지 않는 닫힌 경로를 의미한다. (삼각형을 생각해보자)
+ 부분 그래프(subgraph) : 그래프G'의 정점과 간선들의 집합이 그래프 G에 모두 속한다면 G'를 G의 부분 그래프라고 한다.\
+ 동형 그래프(isomorphic graph) : 모양이 같다는 의미, 그래프 G와 G' 에 대해 다음의 조건을 만족할 때 동형 그래프라고 한다.
  + f : v -> v' (v는 G의 정점집합에 포함, v'은 G'의 정점집합에 포함) - **정점을 매핑하는 함수가 존재하며**
  + (x, y) 가 G의 간선일 때 (f(x), f(y))가 G'의 간선일 경우 - **간선이 매핑될 때**
+ 완전 그래프(complete graph) : 그래프 G가 모든 정점 사이에 연결선이 존재하면 완전 그래프라고 한다. (한 정점에서 다른 모든 정점으로 가는 연결선이 존재한다.) 정점이 m 인 완전 그래프는 Km 으로 표기한다.
+ 이분 그래프(bipartite graph) : 그래프 G의 정점들이 교집합이 존재하지 않는 X, Y 집합으로 나누어져 있고, 모든 연결선이 (x, y) 쌍으로 이루어지는 경우 이분 그래프라고 한다. (같은 집합에 속하는 정점끼리 연결선이 존재하지 않는 경우) 추가적으로 두 집합 X, Y의 모든 정점 사이에 연결선이 존재하는 경우 (X의 임의의 점에서 모든 Y에 속하는 정점에 대해 연결선이 있고, 반대로도 그러할 때) 완전 이분 그래프라고 한다. X, Y에 속하는 정점이 각각 m, n 일 때 Km,n으로 표기한다.
+ 평면 그래프(planar graph) : 그래프 G의 연결선들이 서로 교차하지 않고 평면상에 그릴 수 있는 그래프를 평면 그래프라고 한다.
+ 면(face) : 연결선에 따라 구분된 영역
+ 방향 그래프(directed graph) : 그래프 G에서 연결선의 두 정점이 순서쌍일 때 G는 방향 그래프이다. (방향은 화살표로 표시한다.)



### 그래프 채색
인접하고 있는 정점들은 서로 다른 색을 갖도록 하면서 그래프의 모든 정점에 색을 할당하는 문제, 그래프 채색에 필요한 최소한의 색의 수를 색상수(chromatic number) 라고 하며 x(G) (엑사) 라고 표현한다. 한정된 자원을 반복사용해야하는 모델에서 유용하게 활용될 수 있다. ex) 주파수 할당, 시험 스케줄 구성 등등

+ 특수한 케이스의 그래프 채색

  + 완전 그래프 : 모든 임의의 정점이 자신을 제외한 다른 모든 정점과 연결되어 있으므로 색상수는 정점의 수와 같다. x(Kn) = n
  + 이분 그래프 : 두 개의 집합이 존재하며 한 집합 내에서는 모든 정점이 서로 인접하지 않으므로 모든 이분 그래프의 색상수는 2이다. x(Km,n) = 2 

+ Simple Coloring Algorithm (Greedy한 방식)

  1. 모든 정점들의 순서를 정하고
  2. 모든 색상의 순서를 정한다.
  3. 가장 처음 정점부터 하나씩 조건을 확인하며 가장 순서가 빠른 색상을 할당한다.

  + 이 알고리즘은 최소의 색상수를 보장할까? => No!

  + 이 알고리즘은 정점의 순서를 어떻게 정하는지에 따라서 색상수가 달라질 수 있다. 가장 간단한 예시로 이분 그래프를 생각해보면 정점의 순서를 다른 집합끼리 번갈아서 정할 경우 색상수가 2보다 훨씬 크게 나오게 된다는 것을 알 수 있다.

  + 최소의 색상수를 구하는 것은 간단한 알고리즘으로 구할 수 없는 복잡한 문제.

    

### 최소신장 트리
#### 신장트리?

그래프 G={V, E}에서 V의 모든 정점을 포함하며서 사이클이 존재하지 않는 부분 그래프를 의미한다. 사이클이 존재하면 안되는 모델을 설계할 때 사용할 수 있는 개념이다. ex) LAN 세그먼트를 연결하는 네트워크를 구성하는 문제 등

최소신장 트리는 신장 트리 중 특별하게, 가중 그래프에서 가중치의 합을 최소로하는 신장 트리를 의미한다.

최소 신장트리를 구하는 방법은 다양하지만 대표적인 것들로는 다음과 같은 알고리즘이 있다.

+ 프림(Prim) 알고리즘

  + 그래프에서 하나의 정점을 선택하고 가장 가중치가 적은 간선을 추가한 뒤 집합(트리)로 만드는 것을 반복하는 알고리즘
  + 연속적으로 집합에 포함되지 않은 정점에 도달하는 가중치가 가장 작은 간선을 추가하는 그리디한 알고리즘이다.
  + 기술적으로는 그리디 알고리즘과 동적 계획법을 함께 사용하는 형태라고 할 수 있다.
  + 시간복잡도는 구현 방식에 따라 달라지지만 가장 기본적인 방식으로 생각하면 V개의 정점에 대해 최대 (V-1)개의 연결선에 대해 확인하는 과정이 필요하므로 O(V^2) 의 시간이 걸린다.

+ 크러스컬(Kruskal) 알고리즘

  + 그래프의 간선을 가중치가 적은 순서대로 정렬한 뒤, 하나씩 추가하면서 MST를 만드는 알고리즘

  + 낮은 가중치의 간선을 추가하면서 이미 선택된 간선들과 사이클이 발생하지 않는지 확인하면서 추가한다.

  + 그리디 알고리즘이며 우선 정렬을 해야한다는 특징이 있다.

  + 시간복잡도는 우선 정렬에 필요한 복잡도(퀵 정렬의 경우 ElogE)와 사이클을 확인하기 위해 최대 V개의 정점을 확인해야 하므로 EV 의 시간이 걸린다. 즉 가장 간단한 구현의 경우 O(ElogE + EV) 의 시간이 걸리게 된다.

    

### 최단경로 알고리즘
#### **다익스트라 알고리즘 (이전에 정리한 내용 재사용)**

특정 노드에서 다른 모든 노드로 가는 최단 경로를 계산하는 방법. 음의 간선이 없을 때 정상적으로 작동한다. 그 과정은 다음과 같다.

1. 출발 노드 설정
2. 최단 거리 테이블 초기화(동적계획법)
3. 방문하지 않은 노드 중 최단 거리가 가장 짧은 노드 선택
4. 해당 노드를 거쳐 다른 노드로 가능 비용을 계산, 최단 거리 테이블을 갱신
5. 3과 4를 반복

매 상황에서 방문하지 않은 가장 비용이 적은 노드를 선택하는 것을 통해 처리된 노드의 최단 거리를 고정시켜 단계당 하나의 노드에 대한 최단 거리를 확실히 하는 알고리즘이다.

```python
# 파이썬에서의 구현
import sys
INPUT = sys.stdin.readline
INF = int(1e9)

n, m = map(int, input().split()) #노드와 간선의 수
start = int(input()) #시작 노드 번호
graph = [[] for i in range(n + 1)] #노드 연결 정보 리스트
visited = [False] * (n + 1) #노드 방문 정보 리스트
distance = [INF] * (n + 1) #최단 거리 테이블 초기화

for _ in range(m): #간선 정보 입력
    a, b, c = map(int, input().split()) #a번 노드에서 b번 노드로 가는 비용이 c
    graph[a].append((b, c))

def get_smallest_node(): #방문하지 않은 노드 중 최단 거리가 가장 짧은 노드 번호를 반환
    min_value = INF
    index = 0
    for i in range(1, n + 1):
        if distance[i] < min_value and not visited[i]:
            min_value = distance[i]
            index = i

    return index

def dijkstra(start):
    distance[start] = 0
    visited[start] = True
    for j in graph[start]:
        distance[j[0]] = j[1] #시작 노드로부터 인접한 노드까지 거리 할당
    for i in range(n-1): #시작 노드 제외 n-1개 노드에 대해 반복
        now = get_smallest_node()
        visited[now] = True
        for j in graph[now]:
            cost = distance[now] + j[1]
            if cost < distance[j[0]]:
                distance[j[0]] = cost

dijkstra(start)

for i in range(1, n + 1):
    if distance[i] == INF:
        print("INFINITY")
    else:
        print(distance[i])
```

노드갯수 n번 만큼 최단 거리 테이블 n개를 탐색하므로 n^2에 비례하는 시간 복잡도를 가진다. O(n^2) 일반적으로 노드 개수가 5000개 이하일 경우 다익스트라 알고리즘을 통해 짧은 시간내에 솔루션을 얻을 수 있다.

노드의 개수가 많아질 경우 우선순위 큐 자료구조를 활용할 수 있다. 힙 구조를 이용하여 우선순위 큐를 구현하면 삽입과 삭제 모두 logN에 비례하는 시간복잡도를 가지기 때문에 이점을 얻을 수 있다. 힙은 파이썬 라이브러리를 통해 아래와 같이 구현할 수 있다.

```python
import heapq
#힙 라이브러리를 이용한 오름차순(최소 힙)
def heapsort(iterable):
    h = []
    result = []
    for value in iterable:
        heapq.heappush(h, value)
    for i in range(len(h)):
        result.append(heapq.heappop(h))
    return result

import heapq
#-를 활용하여 내림차순(최대 힙)도 가능하다.
def heapsort(iterable):
    h = []
    result = []
    for value in iterable:
        heapq.heappush(h, -value)
    for i in range(len(h)):
        result.append(-heapq.heappop(h))
    return result
```

힙 구조를 통해 최단거리를 구하는 함수를 없애고 다익스트라 함수를 다음과 같이 수정할 수 있다

```python
import heapq

def dijkstra(start):
    q = []
    heapq.heappush(q, (0, start))
    distance[start] = 0
    while q:
        dist, now = heapq.heappop(q)
        if distance[now] < dist: #별도의 방문여부 리스트 없이 현재 노드의 거리 값이 새로 뽑은 거리 값보다 작다면 이미 처리한 것으로 간주하고 스킵
            continue
        for i in graph[now]:
            cost = dist + i[1]
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                heapq.heappush(q, (cost, i[0]))
```

힙을 활용하여 수정할 경우 노드의 개수 V에 비례하여 반복문을 수행하고 총 간선의 개수 E만큼 다른 노드와 비교하므로 O(ElogV)의 시간 복잡도를 가지게 된다.



#### Bellman-Ford 알고리즘

다익스트라 알고리즘과 같이 single-source에서 모든 정점까지의 최단 거리를 결정하는 알고리즘으로, 방향 / 비방향 그래프 모두에 적용할 수 있다. 다익스트라 알고리즘과 달리 **음의 가중치를 가지는 간선**이 존재할 경우에도 사용할 수 있다. 하지만 **순환을 구성하는 간선의 가중치 합은 양수**여야 한다. 인터넷 라우팅 프로토콜에 사용되는 알고리즘(RIP, BGP)

+ 동적계획법을 활용하는 알고리즘이다.
+ 벨먼-포드 알고리즘은 다음의 방식으로 동작한다.
  + 1. 각 정점까지 도달하는 최단 거리를 기록하는 배열을 초기화한다.(D[1] = 0, D[i] = inf) 최단 거리를 기록하는 배열은 그 정점에 도달하기 이전 정점도 같이 기록한다.
  + 2. 최단 거리 배열은 한 단계마다 D[i] = min(D[k] + dki) 로 갱신된다. 여기서 k는 정점 i와 직접 연결선이 있는 정점이다.
  + 3. 위 과정을 반복하며 수행하며, 더 이상 모든 D[i]에 변화가 생기지 않는다면 반복을 종료한다.
+ 벨먼-포드 알고리즘을 통해 최단 경로를 구할 경우 최단 경로에 해당하는 순서까지 알 수 있다. (앞 정점을 기록하기 때문이다,)
+ 시간복잡도의 경우 각 정점에 대해 모든 직접 연결된 간선의 비용을 다시 계산하면서 갱신하는 방식으로 진행되므로 결국 인접한 모든 간선들을 검사하는 것과 같다. 따라서 O(VE) 의 시간복잡도를 가지게 된다.
